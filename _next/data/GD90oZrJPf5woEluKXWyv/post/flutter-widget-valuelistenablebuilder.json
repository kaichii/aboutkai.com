{"pageProps":{"post":{"title":"Flutter Widget: ValueListenableBuilder","date":1618358400,"slug":"flutter-widget-valuelistenablebuilder","author":"kaichi","content":"<p>相信大家一定用过 <code>setState</code>, 在 <code>StatefulWidget</code> 中我们常使用 <code>setState</code> 来更新组件状态以此来更新 ui。下面这个计数器的 🌰 大家非常熟悉。</p>\n<pre><code class=\"language-dart\">class _CounterState extends State&#x3C;Counter> {\n  int _count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Text(\n          'You had tapped $_count.',\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        child: Icon(Icons.add),\n        onPressed: () => setState(() => _count++),\n      ),\n    );\n  }\n}\n</code></pre>\n<p>今天给大家介绍的 <strong>ValueListenableBuilder</strong>, 可以让我们更新的的组件状态而不需要使用<code>setState</code>。<strong>ValueListenableBuilder</strong> 有两个必须必需的参数。<em>valueListenable</em> 是 <strong>ValueNotifier</strong> 实例，<em>builder</em> 是一个回调函数，该回调函数根据所监听的值来构建组件，使用 <strong>ValueListenableBuilder</strong> 实现一个计数器。</p>\n<p>你会发现这样一个计数器依旧是正常工作的，既然我们没有使用 <code>setState</code> 方法，组件是如何更新的呢？</p>\n<p><strong>ValueListenableBuilder</strong> 会监听 <strong>ValueListenable</strong> 上的任何更改，因此可以在值更改后重建 UI。这也是目前为止唯一可以基于组件当前状态重构 UI 的方法，当点击按钮使 counter 的 value 更新后，更新的也只是 Text 组件，而不需要整个页面重构。</p>\n<p>除了上面的两个参数，<strong>ValueListenableBuilder</strong> 还有另外一个参数 <em>child</em>。上面的计数器 <em>builder</em> 返回一个 <strong>Text</strong> 组件展示 counter 的值，当 counter 的值改变时需要重构的组件也就是这个 <strong>Text</strong> 组件。但有时 <em>builder</em> 返回了一个非常复杂的组件，但是只有一部分组件依赖 value。这是我们就要用的 <em>child</em> 参数，例如下面这个 🌰。</p>\n<pre><code class=\"language-dart\">ValueListenableBuilder(\n  valueListenable: _counter,\n  builder: (context, value, child) => Container(\n    width: 200,\n    height: 200,\n    color: value % 2 == 0 ? Colors.blue : Colors.red,\n    alignment: Alignment.center,\n    child: child,\n  ),\n  child: Container(\n    color: Colors.green,\n    width: 100,\n    height: 100,\n  ),\n)\n</code></pre>\n<p>当 value 改变时，只有外面的 <strong>Container</strong> 会重构，而内部 <strong>Container</strong> 则不会重构。</p>\n<blockquote>\n<p>记得销毁 <strong>ValueNotifier</strong>, 避免内存泄漏。就像这样。</p>\n</blockquote>\n<pre><code class=\"language-dart\">  @override\n  void dispose() {\n    _counter.dispose();\n    super.dispose();\n  }\n</code></pre>\n","excerpt":"ValueListenableBuilder 组件介绍"}},"__N_SSG":true}