{"pageProps":{"post":{"title":"Flutter 最佳实践","date":1618358400,"slug":"flutter-best-practice","author":"kaichi","content":"<h4>命名规范</h4>\n<p>类、枚举、typedef 和 extension 名应为大驼峰(UpperCamelCase)。</p>\n<pre><code class=\"language-dart\">class HomePage { ... }\nenum PageState { ... }\ntypedef Predicate&#x3C;T> = bool Function(T value);\nextension MyList&#x3C;T> on List&#x3C;T> { ... }\n</code></pre>\n<p>库、包、文件夹和文件名应为小写蛇形(lowercase_with_underscores)。</p>\n<pre><code class=\"language-dart\">library firebase_dynamic_links;\nimport 'socket/socket_manager.dart';\n</code></pre>\n<p>变量、常量、参数和命名参数名应为小驼峰(lowerCamelCase)。</p>\n<pre><code class=\"language-dart\">var item;\nconst bookPrice = 3.14;\nfinal urlScheme = RegExp('^([a-z]+):');\nvoid sum(int bookPrice) {\n  // ...\n}\n</code></pre>\n<h4>使用相对路径导入文件</h4>\n<p>在同时使用相对和绝对路径导入时，使用两种方式导入同一类时可能会造成混乱，为了避免这种情况，在 lib/ 下使用相对路径。</p>\n<pre><code class=\"language-dart\">// Do\nimport \"../../utils/demo.dart\";\n\n// Don`t\nimport \"package:demo/src/utils/demo.dart\";\n</code></pre>\n<h4>指定值类型</h4>\n<p>对于知道类型的值，指定其类型，尽可能避免使用 <code>var</code>。</p>\n<pre><code class=\"language-dart\">//Don't\nvar item = 10;\nfinal car = Car();\nconst timeOut = 2000;\n\n\n//Do\nint item = 10;\nfinal Car bar = Car();\nString name = 'john';\nconst int timeOut = 20;\n</code></pre>\n<h4>使用 <code>is</code> 而不是 <code>as</code></h4>\n<p><code>as</code> 转换类型失败则会抛出异常，为了避免这种情况，应使用 <code>is</code> 判断类型。</p>\n<pre><code class=\"language-dart\">//Don't\n(item as Animal).name = 'Lion';\n\n\n//Do\nif (item is Animal)\n  item.name = 'Lion';\n</code></pre>\n<h4>使用 <code>if</code> 而不是条件表达式</h4>\n<p>很多时候我们会根据某些条件去渲染组件，但是如果在某种条件下不需要返回任何组件时应使用 <code>if</code>。</p>\n<pre><code class=\"language-dart\">//Don't\nWidget getText(BuildContext context) {\n  return Row(\n    children: [\n      Text(\"Hello\"),\n      display ? Text(\"hello\") : Container(),\n    ]\n  );\n}\n\n\n//Do\nWidget getText(BuildContext context) {\n  return Row(\n      children:\n      [\n        Text(\"Hello\"),\n        if (display) Text(\"hello\")\n      ]\n  );\n}\n</code></pre>\n<h4>使用 <code>??</code> 和 <code>?.</code> 操作符</h4>\n<p>使用 <code>??</code> 和 <code>?.</code> 操作符，避免空值检查。</p>\n<pre><code class=\"language-dart\">//Don't\nv = a == null ? b : a;\n\n//Do\nv = a ?? b;\n# a != null: v = a\n# a = null: v = b\n\n\n//Don't\nv = a == null ? null : a.b;\n\n//Do\nv = a?.b;\n</code></pre>\n<h4>使用 <code>...</code> 解构</h4>\n<p>使用 <code>...</code> 解构让代码看起来更简洁。</p>\n<pre><code class=\"language-dart\">//Don't\nvar y = [4,5,6];\nvar x = [1,2];\nx.addAll(y);\n\n\n//Do\nvar y = [4,5,6];\nvar x = [1,2,...y];\n</code></pre>\n<h4>使用 <code>..</code> 级连运算符</h4>\n<p>使用 <code>..</code> 级连运算符对同一对象执行一系列操作。</p>\n<pre><code class=\"language-dart\">// Don't\nvar path = Path();\npath.lineTo(0, size.height);\npath.lineTo(size.width, size.height);\npath.lineTo(size.width, 0);\npath.close();\n\n\n// Do\nvar path = Path()\n..lineTo(0, size.height)\n..lineTo(size.width, size.height)\n..lineTo(size.width, 0)\n..close();\n</code></pre>\n<h4>使用原始字符串</h4>\n<p>原始字符串可以避免转译 \\ 和 $</p>\n<pre><code class=\"language-dart\">//Don't\nvar s = 'This is demo string \\\\ and \\$';\n\n\n//Do\nvar s = r'This is demo string \\ and $';\n</code></pre>\n<h4>不要显式初始化变量为 null</h4>\n<p>在 Dart 中，变量的默认值为 null， 初始化为 null 很多余。</p>\n<pre><code class=\"language-dart\">//Don't\nint a = null;\n\n\n//Do\nint a;\n</code></pre>\n<h4>箭头函数</h4>\n<p>对于只有一个表达式的函数，推荐使用 <code>=></code>。</p>\n<pre><code class=\"language-dart\">//Don't\nget width {\n  return right - left;\n}\nWidget getProgressBar() {\n  return CircularProgressIndicator(\n    valueColor: AlwaysStoppedAnimation&#x3C;Color>(Colors.blue),\n  );\n}\n\n\n//Do\nget width => right - left;\nWidget getProgressBar() => CircularProgressIndicator(\n      valueColor: AlwaysStoppedAnimation&#x3C;Color>(Colors.blue),\n    );\n</code></pre>\n<h4>避免使用 <code>print</code> 方法</h4>\n<p><code>print()</code> 和 <code>debugPrint()</code> 都用于在控制台输出，如果使用 <code>print()</code> 并且一次输出太多，有时会丢弃输入，为了避免这种情况，建议使用 <code>debugPrint()</code>。</p>\n<h4>拆分复杂组件</h4>\n<p>当 <code>setState</code> 更新状态时，所有的子组件都将重建，为了减少不必要的重建，应将复杂组件拆分为一个个小组件，在小组件内部 <code>setState</code> 更新相应部分。</p>\n<h4>使用 <strong>ListView.builder</strong> 构建长列表</h4>\n<p>当你有一个无限或是非常长的列表时，通常建议使用 <code>ListView</code> 组件来展示。 <code>ListView</code> 会一次构建整个列表。</p>\n<p>为了提高性能，避免不必要的资源浪费，推荐使用 <code>ListView.builder</code>，<code>ListView.builder</code> 会创建一个懒加载列表，当用户滚动列表时，<strong>Flutter</strong> 会按需加载。</p>\n<h4>使用 <code>const</code> 声明不需要更新的组件</h4>\n<p>对于在 <code>setState</code> 调用不需要更新的组件，应将其定义为常量，可以防止不必要的重建，从而提高性能。</p>\n<pre><code class=\"language-dart\">Container(\n      padding: const EdgeInsets.only(top: 10),\n      color: Colors.black,\n      child: const Center(\n          child: const Text(\"hello world\"),\n      ),\n);\n</code></pre>\n","excerpt":"flutter 最佳实践"}},"__N_SSG":true}