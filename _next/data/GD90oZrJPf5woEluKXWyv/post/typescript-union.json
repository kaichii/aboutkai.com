{"pageProps":{"post":{"title":"Typescript 辨别联合类型","date":1617321600,"slug":"typescript-union","author":"kaichi","content":"<p>在使用联合类型时，通常需要判断联合类型的具体类型，考虑如下 🌰</p>\n<pre><code class=\"language-ts\">interface Square {\n  kind: \"square\";\n  size: number;\n}\n\ninterface Rectangle {\n  kind: \"rectangle\";\n  width: number;\n  height: number;\n}\n\ntype Shape = Square | Rectangle;\n</code></pre>\n<p><code>Square</code> 和 <code>Rectangle</code> 有共同字面量成员 <code>kind</code>，一般联合类型的成员有一些自己的行为，此时可以根据 <code>kind</code> 属性来判断联合类型，例如下面计算面积的 function。</p>\n<pre><code class=\"language-ts\">function area(s: Shape) {\n  if (s.kind === \"square\") {\n    // 现在 TypeScript 知道 s 的类型是 Square\n    // 所以你现在能安全使用它\n    return s.size * s.size;\n  } else {\n    // 不是一个 square ？因此 TypeScript 将会推算出 s 一定是 Rectangle\n    return s.width * s.height;\n  }\n}\n</code></pre>\n<p>一切都很完美，如果此时 <code>Shape</code> 类型增加了一种类型。</p>\n<pre><code class=\"language-ts\">interface Circle {\n  kind: \"circle\";\n  radius: number;\n}\n\ntype Shape = Square | Rectangle | Circle;\n</code></pre>\n<p>这时计算面积的 Function 缺少对 <code>Circle</code> 类型的处理逻辑，但是你会发现它并不会给你抛出任何错误，这是很糟糕的。</p>\n<pre><code class=\"language-ts\">function area(s: Shape) {\n  if (s.kind === \"square\") {\n    return s.size * s.size;\n  } else if (s.kind === \"rectangle\") {\n    return s.width * s.height;\n  }\n\n  // 如果你能让 TypeScript 给你一个错误，这是不是很棒？\n}\n</code></pre>\n<p>你可以通过确保块中的类型被推断为与 <code>never</code> 类型兼容的类型，以此来捕获错误，例如：</p>\n<pre><code class=\"language-ts\">function area(s: Shape) {\n  if (s.kind === \"square\") {\n    return s.size * s.size;\n  } else if (s.kind === \"rectangle\") {\n    return s.width * s.height;\n  } else {\n    // 此时类型被判断为 `Circle`\n    // Error: 'Circle' 不能被赋值给 'never'\n    const _exhaustiveCheck: never = s;\n  }\n}\n</code></pre>\n<p>它将强制你添加一种新的条件。</p>\n<pre><code class=\"language-ts\">function area(s: Shape) {\n  if (s.kind === \"square\") {\n    return s.size * s.size;\n  } else if (s.kind === \"rectangle\") {\n    return s.width * s.height;\n  } else if (s.kind === \"circle\") {\n    return Math.PI * s.radius ** 2;\n  } else {\n    // 此时类型收缩为 `never`\n    const _exhaustiveCheck: never = s;\n  }\n}\n</code></pre>\n<p>你可以通过 <code>switch</code> 实现以上例子。</p>\n<pre><code class=\"language-ts\">function area(s: Shape) {\n  switch (s.kind) {\n    case \"square\":\n      return s.size * s.size;\n    case \"rectangle\":\n      return s.width * s.height;\n    case \"circle\":\n      return Math.PI * s.radius ** 2;\n    default:\n      // 此时类型收缩为 `never`\n      const _exhaustiveCheck: never = s;\n  }\n}\n</code></pre>\n<p>如果你使用 <code>strictNullChecks</code> 选项来做详细的检查，你应该返回 <code>_exhaustiveCheck</code> 变量（类型是 <code>never</code>），否则 TypeScript 可能会推断返回值为 <code>undefined</code>。</p>\n<pre><code class=\"language-ts\">function area(s: Shape) {\n  switch (s.kind) {\n    case \"square\":\n      return s.size * s.size;\n    case \"rectangle\":\n      return s.width * s.height;\n    case \"circle\":\n      return Math.PI * s.radius ** 2;\n    default:\n      const _exhaustiveCheck: never = s;\n      return _exhaustiveCheck;\n  }\n}\n</code></pre>\n","excerpt":"Tempor sunt tempor voluptate nulla labore nostrud deserunt pariatur commodo elit laborum nisi aliquip."}},"__N_SSG":true}