---
title: JavaScript 中的值和引用
publishedAt: "2021-12-20"
description: ""
---

在 JavaScript 中，有 7 种数据类型通过值传递: `null`、`undefined`、`Boolean`、`Number`、`String`、`BigInt` 和 `Symbol`([ECMAScript](https://developer.mozilla.org/zh-CN/docs/Glossary/ECMAScript) 2016 新增)，我们称之为[原始类型](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)。另外对象数据类型通过引用传递，其中包括 `Object`、`Array`、`Function`、`Map`、`Set`...除原始类型外的类型。

> Number 是指数据类型，和 number 语义上没有区别，不要和 Number() 混淆。

## 原始类型

如果原始类型的值被赋值给变量，我们可以认为该变量持有该原始值。

```js
var x = 10;
var y = "abc";
var z = null;
```

现在 `x` 持有值 `10`，`y` 持有值 `abc`，我们可以想象他们在内存里是这样的。

| 变量 | 值    |
| ---- | ----- |
| x    | 10    |
| y    | 'abc' |
| z    | null  |

当我们把变量用 `=` 赋值给另一个变量时，我们复制了该变量的值，被赋值的变量则拥有了被复制的值。

```js
var x = 10;
var y = "abc";

var a = x;
var b = y;

console.log(x, y, a, b); // -> 10, 'abc', 10, 'abc'
```

现在 `x` 和 `a` 持有值 `10`，`y` 和 `b` 持有值 `'abc'`，但是他们的值之间没有关系。

| 变量 | 值    |
| ---- | ----- |
| x    | 10    |
| y    | 'abc' |
| a    | 10    |
| b    | 'abc' |

改变其中一个不会影响到另外一个，因为这些值之间是没有联系的。

```js
var x = 10;
var y = "abc";

var a = x;
var b = y;

a = 5;
b = "def";

console.log(x, y, a, b); // -> 10, 'abc', 5, 'def'
```

## 对象类型

当非原始类型的值被赋值给变量时，变量得到的是该值的引用，该引用指向值存储的位置，变量并没有获得该值，只是引用。

对象被创建后，储存在内存中的某个位置。当我们在写 `arr = []` 时，我们在内存中创建了一个数组，变量 `arr` 得到一个指向该数组的 `address`。

我们假设这个 `address` 和 `Number` 或 `String` 这些原始数据类型一样通过值传递。`address` 指向值在内存中的位置。和字符串用引号表示一样，我们使用 `<>` 表示。

```js
1) var arr = [];
2) arr.push(1);
```

我们将上面两行代码在内存中表示

1.

| 变量 | 值         | 地址 | 对象 |
| ---- | ---------- | ---- | ---- |
| arr  | {'<#001>'} | #001 | []   |

2.

| 变量 | 值         | 地址 | 对象 |
| ---- | ---------- | ---- | ---- |
| arr  | {'<#001>'} | #001 | [1]  |

我们可以看到，变量 `arr` 包含的值和地址是静态的，内存中的数组是变化的。当我们往 `arr` 中添加一个元素时，JS 引擎会找到内存中数组所在的位置并操作储存在那的数据。

### 引用赋值

我们将一个对象，通过 `=` 操作符赋值给一个变量时，该变量接受到该对象的地址的复制，就像原始类型赋值那样。对象被复制的是其引用而不是其值。

```js
var reference = [1];
var refCopy = reference;
```

在内存中表示

| 变量      | 值         | 地址 | 对象 |
| --------- | ---------- | ---- | ---- |
| reference | {'<#001>'} | #001 | [1]  |
| refCopy   | {'<#001>'} |      |      |

数组对象的值没有被复制一份，复制的是其引用。现在 `reference` 和 `refCopy` 持有同一个数组的引用。当我们修改 `reference`，`refCopy` 也会被修改。

```js
reference.push(2);
console.log(reference, refCopy); // -> [1, 2], [1, 2]
```

| 变量      | 值         | 地址 | 对象  |
| --------- | ---------- | ---- | ----- |
| reference | {'<#001>'} | #001 | [1,2] |
| refCopy   | {'<#001>'} |      |       |

当给变量重新赋值新的引用时，新引用将替换旧的引用。

```js
var obj = { first: "reference" };
```

| 变量      | 值         | 地址 | 对象                     |
| --------- | ---------- | ---- | ------------------------ |
| reference | {'<#234>'} | #234 | \{ first: "reference" \} |

当我们给 `obj` 重新赋值时，新的引用值会替换掉旧的值。

```js
var obj = { first: "reference" };
obj = { second: "ref2" };
```

储存在 `obj` 里的地址改变了，之前的对象依然在内存中原来的位置。

| 变量      | 值         | 地址 | 对象                     |
| --------- | ---------- | ---- | ------------------------ |
| reference | {'<#234>'} | #234 | \{ first: "reference" \} |
|           |            | #678 | \{ second: "ref2" \}     |
