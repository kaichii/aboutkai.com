---
title: JavaScript 中的值和引用
publishedAt: "2021-12-20"
description: ""
---

在 JavaScript 中，有 7 种原始数据类型通过值传递: `null`、`undefined`、`Boolean`、`Number`、`String`、`BigInt` 和 `Symbol`。

另外对象数据类型通过引用传递，其中包括 `Object`、`Array`、`Function`、`Map`、`Set`...除原始类型外的类型。

## 原始类型

如果原始类型的值被赋值给变量，我们可以认为该变量持有该原始值。

```js
var x = 10;
var y = "abc";
var z = null;
```

现在 `x` 持有值 `10`，`y` 持有值 `abc`，我们可以想象他们在内存里是这样的。

| 变量 | 值    |
| ---- | ----- |
| x    | 10    |
| y    | 'abc' |
| z    | null  |

当我们把变量用 `=` 赋值给另一个变量时，我们复制了该变量的值，被赋值的变量则拥有了被复制的值。

```js
var x = 10;
var y = "abc";

var a = x;
var b = y;

console.log(x, y, a, b); // -> 10, 'abc', 10, 'abc'
```

现在 `x` 和 `a` 持有值 `10`，`y` 和 `b` 持有值 `'abc'`，但是他们的值之间没有关系。

| 变量 | 值    |
| ---- | ----- |
| x    | 10    |
| y    | 'abc' |
| a    | 10    |
| b    | 'abc' |

改变其中一个不会影响到另外一个，因为这些值之间是没有联系的。

```js
var x = 10;
var y = "abc";

var a = x;
var b = y;

a = 5;
b = "def";

console.log(x, y, a, b); // -> 10, 'abc', 5, 'def'
```

## 对象类型

当非原始类型的值被赋值给变量时，变量得到的是该值的引用（一个内存地址），该引用指向值存储的位置，变量并没有获得该值。

当我们在写 `arr = []` 时，会在分配内存中的一块用于储存该数组，变量 `arr` 得到一个指向该数组的 `address`。

我们假设这个 `address` 和 `Number` 或 `String` 这些原始数据类型一样通过值传递。`address` 指向值在内存中的位置。我们使用 `<>` 表示，像字符串用引号表示一样。

```js
1) var arr = [];
2) arr.push(1);
```

我们将上面两行代码在内存中表示:

1

| 变量 | 值         | 地址 | 对象 |
| ---- | ---------- | ---- | ---- |
| arr  | {'<#001>'} | #001 | []   |

2

| 变量 | 值         | 地址 | 对象 |
| ---- | ---------- | ---- | ---- |
| arr  | {'<#001>'} | #001 | [1]  |

变量 `arr` 持有的值和地址是静态的，内存中的数组是变化的。当我们往 `arr` 中添加一个元素时，JS 引擎会找到内存中数组所在的位置并操作储存的数据。

### 引用赋值

我们将一个对象，通过 `=` 操作符赋值给一个变量时，该变量接受到该对象的地址的复制，就像原始类型赋值那样。对象被复制的是其引用而不是其值。

```js
var reference = [1];
var refCopy = reference;
```

在内存中表示:

| 变量      | 值         | 地址 | 对象 |
| --------- | ---------- | ---- | ---- |
| reference | {'<#001>'} | #001 | [1]  |
| refCopy   | {'<#001>'} |      |      |

数组对象的值没有被复制一份，复制的是其引用。现在 `reference` 和 `refCopy` 持有同一个数组的引用。当我们修改 `reference`，`refCopy` 也会被修改。

```js
reference.push(2);
console.log(reference, refCopy); // -> [1, 2], [1, 2]
```

| 变量      | 值         | 地址 | 对象  |
| --------- | ---------- | ---- | ----- |
| reference | {'<#001>'} | #001 | [1,2] |
| refCopy   | {'<#001>'} |      |       |

当给变量重新赋值新的引用时，新引用将替换旧的引用。

```js
var obj = { first: "reference" };
```

| 变量      | 值         | 地址 | 对象                     |
| --------- | ---------- | ---- | ------------------------ |
| reference | {'<#234>'} | #234 | \{ first: "reference" \} |

当我们给 `obj` 重新赋值时，变量获得了新的引用。

```js
var obj = { first: "reference" };
obj = { second: "ref2" };
```

`obj` 持有的引用改变了，对象依然存在在内存中。

| 变量      | 值         | 地址 | 对象                     |
| --------- | ---------- | ---- | ------------------------ |
| reference | {'<#234>'} | #234 | \{ first: "reference" \} |
|           |            | #678 | \{ second: "ref2" \}     |

此时上面的对象 `#234` 没有被别的变量引用，JS 引擎可以对其进行垃圾回收。这意味着我们不再引用该对象，因此 JS 引擎可以放心地将其从内存中删除。

### == 和 ===

当我们在用 `==` 和 `===` 操作符比较引用类型的变量是否相等时，比较的是引用。如果两个变量持有相同的引用，则返回 `true`。

```js
var arrRef = ["Hi!"];
var arrRef2 = arrRef;
console.log(arrRef === arrRef2); // -> true
```

如果他们是不同的对象，即使他们的值一样，结果也为 `false`。

```js
var arr1 = ["Hi!"];
var arr2 = ["Hi!"];
console.log(arr1 === arr2); // -> false
```
