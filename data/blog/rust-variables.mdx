---
title: Rust 变量绑定与解构
publishedAt: '2022-01-23'
description: '声明变量是学习一门语言的基础。在其他大多数语言中，变量一旦创建，要么是可变的，要么是不可变的。'
---

声明变量是学习一门语言的基础。在其他大多数语言中，变量一旦创建，要么是可变的，要么是不可变的。可变变量为编程提供了灵活性，不可变变量为编程提供了安全性。而 Rust 表示: 我全都要!

## 变量绑定

使用 `let` 关键字声明变量。

```rust
let a = "hello world";
```

为什么是绑定而不是赋值呢（也可以理解为赋值，但是绑定的含义更加准确）？这就涉及到 Rust 中的*所有权*概念，简单来讲，任何内存对象都是有主人的，而且一般情况完全属于它的主人，把这个对象绑定给一个变量，这个变量就成为它的主人，`a` 现在是 `"hello world"` 的主人。

## 变量可变性

Rust 中变量默认是*不可变的*。

```rust
let a = 1;
println!("a 的值为 {}", a); // -> a 的值为 1
a = 2;
println!("a 的值为 {}", a);
// 错误 cannot assign twice to immutable variable `a`
```

如果想让变量可变，使用 `mut` 关键字。

```rust
let a = 1;
println!("a 的值为 {}", a); // -> a 的值为 1
a = 2;
println!("a 的值为 {}", a); // -> a 的值为 2
```

变量默认不可变和常量有什么区别？

- 常量使用 `const` 关键字声明且必须标注类型。
- 常量不能使用 `mut`。常量不仅默认不可变，而且始终不可变。

声明一个常量

```rust
const PI: f32 = 3.14
```

## 变量解构

`let` 表达式不仅可以用于变量绑定，还能进行复杂变量的解构。

```rust
let (a, mut b):(bool,bool) = (true, false);

a; // true, 不可变
b; // false, 可变

b = true; // true
```

## 变量遮蔽

Rust 允许声明相同的变量名，在后面的声明的变量会遮蔽掉前面声明的。

```rust
let x = 5;
let x = x + 1;

{
  let x = x * 2;
  println!("{}", x); // -> 12
}

println!("{}", x); // -> 6
```

后声明的 `x` 遮蔽掉了前面的 `x`，并取原来的值加 `1`，值为 `6`，花括号作用域的 `x` 同样遮蔽前面的 `x`，并取之前的值乘 `2`（但是只限该作用域），值为 `12`。

和使用 `mut` 声明的变量不同的是，第二个 `let` 生成了完全不同的新变量，两个变量只是名字相同，涉及一次内存对象的分配，而 `mut` 声明的变量，可以修改同一内存地址上的值，不用重新分配内存，性能更好。

变量遮蔽的用处是，如果你在某个作用域内不再需要使用之前的变量，就可以复用这个变量的名字。

```rust
// 字符串类型
let spaces = "    ";
// usize 类型
let spaces = spaces.len();
```

这样我们复用了 `spaces` 这个变量名，不用再花心思想另外一个名字。

使用 `mut`。

```rust
let mut spaces = "    ";

spaces = spaces.len(); // 类型错误 mismatched types
```
